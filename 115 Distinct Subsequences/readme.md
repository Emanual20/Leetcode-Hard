考虑用dp\[i]\[j]来代表字符串s[i:]和t[j:] (表示含义同python切片) 匹配次数

则我们最终需要求解的s和t的匹配次数为dp\[0]\[0]

再考虑一般情况：

假定s[i]和t[j]相同，我可以选择匹配模式串的字符也可以选择不匹配模式串的字符，因此匹配模式串的字符对应dp\[i+1]\[j+1]，不匹配模式串的字符对应dp\[i+1]\[j]；

反之不同，我只能选择不匹配，因此该种次数对应dp\[i+1][j]

$$ dp[i][j]=\left\{
\begin{aligned}
x & = dp[i+1][j+1] + dp[i+1][j]& s[i] == t[j] \\
y & = dp[i+1][j] & s[i] != t[j] \\
\end{aligned}
\right.$$

转移方程解决了我们大多数的情况，接下来只需要解决起始状态就可以了。

$$dp[k][t.length()],dp[s.length()][k]$$，这里k为任意值，分别给1和0即可，因为可以在任意的串中找到空串匹配，空串中却找不到任意非空串匹配。

从下到上dp即可